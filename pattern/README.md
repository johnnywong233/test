# 设计模式学习专题
## 创建型模式
### 原型模式 prototype
在原型模式中我们可以利用过一个原型对象来指明我们所要创建对象的类型，然后通过复制这个对象的方法来获得与该对象一模一样的对象实例。这就是原型模式的设计目的。

浅拷贝：使用一个已知实例对新创建实例的成员变量逐个赋值，这个方式被称为浅拷贝。

深拷贝：当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用类型的成员变量创建新的实例，并且初始化为形式参数实例值。


参考：
- [1](https://www.cnblogs.com/chenssy/p/3313339.html)

##  结构型模式
### 适配器模式 adapter
适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。适配器模式有类的适配器模式和对象的适配器模式两种不同的形式。

类的适配器模式把适配的类的API转换成为目标类的API。

参考：
- [1](http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html)
- [2](http://mp.weixin.qq.com/s?__biz=MzA5MTQyNDU1MQ==&mid=2247483786&idx=1&sn=a2efd75d6a85790b1c659f9b49371544&mpshare=1&scene=1&srcid=1226AvAkhEE6BiakI8SBpQ6g#rd)

### 外观/门面模式 facade
外观模式Facade，隐藏系统的复杂性，并向客户端提供一个可以访问系统的接口。这种类型的设计模式属于结构性模式。为子系统中的一组接口提供一个统一的访问接口，这个接口使得子系统更容易被访问或者使用。 

参考：
- [1](https://www.cnblogs.com/lthIU/p/5860607.html)

### 享元模式 flyweight
享元模式有点类似于单例模式，都是只生成一个对象来被共享使用。为了避免对共享对象的修改，将这些对象的公共部分，或者说是不变化的部分抽取出来形成一个对象。这个对象就可以避免到修改的问题。

享元的目的是为了减少不必要的额外内存消耗，将多个对同一对象的访问集中起来，不必为每个访问者创建一个单独的对象，以此来降低内存的消耗。

参考：
- [1](https://www.cnblogs.com/V1haoge/p/6542449.html)


## 行为型模式

### 策略模式 strategy
参考： 
- [1](http://blog.csdn.net/zhangliangzi/article/details/52161211)

### 观察者模式 observer
观察者模式的定义：在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。
该模式包含四个角色
- 抽象被观察者角色：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。
- 抽象观察者角色：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。
- 具体被观察者角色：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。
- 具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。

参考：
- [1](https://www.cnblogs.com/luohanguo/p/7825656.html)

### 责任链模式 
将能够处理同一类请求的对象连成一条链，如果不能处理则传递给链上的下一个对象。

应用场景：try catch, javascript 冒泡，servlet filter, struts2 拦截器


参考：
- [1](https://www.cnblogs.com/ysw-go/p/5432921.html)
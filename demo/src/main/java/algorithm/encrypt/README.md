RSA 很少用来做加密算法使用，一般多数用于数据签名算法中。这是由于 RSA 作为加密算法进行加密处理时，其所能处理的原文数据量不能超过 （RSA 长度 / 8 - 11），比如：RSA 1024 进行加密运算时，原文的长度不能超过 117 个字节。

你这个安全数据传输可以改进一下，可以参照 SSL/TLS 协议握手的原理，AES 密钥不是固定的，由通信双方各随机生成一半，双方生成的一半密钥通过对方的 RSA 公钥加密传送给对方，对方使用自己的 RSA 私钥解密，这样与自己的另外一半 AES 密钥拼合成数据传输的加密密钥，从而完成密钥的交换过程。

这一块是用于移动客户端，架构上只要保证客户端的数据不被窃取即可。 客户端的AES密钥是随机生成，RSA加密不用于加密数据，而是用来加密AES的密钥。 因为客户端不是支付类的客户端，所以没有对每台终端生成独立的私钥证书。
另外，之前客户端与服务端的交互是短连接，每次交互都随机生成AES密钥，数据用AES加密，AES密钥用RSA加密，每次请求同时传递密文和加密后的AES密钥； 
现在的方案是，客户端启动后，先进行一次检查公钥证书的交互，再进行一次激活交互，激活交互用于客户端传递AES密钥（128位，使用RSA公钥加密），服务端返回激活流水，后续的交互，客户端使用激活时设定的AES密钥进行数据加密。

### AES与3DES的比较
| 算法名称 | 算法类型 | 密钥长度 | 速度 | 解密时间（假设机器每秒尝试255个密钥） | 资源消耗 | 
| ------ |:--------:|-------:|-------:|-------:|-------:|
| AES | 对称block密码 | 128、192、256位 | 高 | 149*10^4亿年 | 低 | 
| 3DES | 对称feistel密码 | 112位或168位 | 低 | 46亿年 | 中 | 